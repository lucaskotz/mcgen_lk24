// MCGEN: generates a requested number of Monte-Carlo replicas from
// input Monte-Carlo or Hessian error PDFs. Saves them in the form of
// LHAPDF6 grids and .plt files for conversion into meta-parametrizations
//
// Author: Jun Gao, Pavel Nadolsky, Lucas Kotz
//
// Description: ninput PDF sets are read from the input LHAPDF6 grid. If the
// input PDFs are Hessian, nmc output replicas are generated by random
// displacements of the input replilcas, distributed according
// to a Gaussian distribution. If the input PDFs are
// Monte-Carlo ones, nmc input replicas are just copied into
// the output replicas. The x values, Q values, and random displacement
// values  are read from input files in the ../inc directory:
// xgrid-lha6.dat, qgrid-lha6.dat, randnum_xxx.dat, etc.
// Optionally, a parameter nstart can be passed to force generation to
// begin from the nstart-th replica in the (always hard-wired)
// random sequence.
//
//
// History
// 2023       LK Modified functions to be more dynamic by reading LHAPDF data
//               Routines include NQ subgrids instead of just 1 for Q0.
//               Q, x, and flavors are exported to external files for 
//               routine used.
// 2017-01-10 PN Fixed writing the values for x=1
// 2016-06-06 PN A cleaned-up version for public release
//========================================================================
#include "LHAPDF/LHAPDF.h"

#include <string>
#include <vector>
#include <map>
#include <iomanip>
#include <iostream>
#include <fstream>
#include <math.h>
#include <time.h>
#include <boost/foreach.hpp>
#include <boost/algorithm/string.hpp>
#include <boost/lexical_cast.hpp>
// lk23 added header containing custom class object
#include "subgrid.h"
#include "LHAPDF/GridPDF.h"
#include "LHAPDF/Paths.h"

using namespace std;
using namespace boost::algorithm;

//========================================================================

string cardname = "mcgen.card", inpdfname = "CT14nnlo", outpdfname = "mcCT14nnlo",
       err_type = "he90";
string xlhaname = "../inc/xgrid-lha6.dat", qlhaname = "../inc/qgrid-lha6.dat",
       xpltname = "../inc/xgrid-plt.dat", qpltname = "../inc/qgrid-plt.dat";
unsigned short int nmc = 100, nstart = 1;
short int nsym = 1, nshift = 0, ktype = 1;
const double small = 1.0e-10;

int MCread_card();
int MCGenerateLHAPDF();
int MCLHAPDF2plt();
int MCStdDevs();
int MCaverage(int argc, char *argv[]);
int MCadd(int argc, char *argv[]);
// lk23 added function to sort flavors in plt order
bool pltSort(int a, int b);

int main(int argc, char *argv[])
{
  //========================================================================
  if (argc < 3)
  {
    cout << "Usage examples" << endl;
    cout << "   mcgen.x generate mcgen.card" << endl;
    cout << "   mcgen.x convert LHAPDF_set" << endl;
    cout << "   mcgen.x std_devs LHAPDF_set error_type" << endl;
    cout << "   mcgen.x average average.dat input1.dat input2.dat ..." << endl;
    cout << "   mcgen.x add sum.dat input1.dat input2.dat w1 w2" << endl;
    cout << "   mcgen.x multiply prod.dat input1.dat input2.dat power1 power2" << endl;
    cout << "Stop: too few parameters passed to mcgen" << endl;
    exit(1);
  }

  if (strcmp(argv[1], "generate") == 0)
  { // Generate random replicas,
    // by reading parameters from the input card cardname;
    cardname = argv[2];
    MCread_card(); // Read parameters from the input card
    MCGenerateLHAPDF();
  }
  else if (strcmp(argv[1], "convert") == 0)
  { // Create .plt grids from
    // LHAPDF6 grids
    inpdfname = argv[2];
    MCLHAPDF2plt();
  }
  else if (strcmp(argv[1], "std_devs") == 0)
  { // Create .er files containing
    // standard deviations for PDFs and other miscellaneous information
    if (argc < 4)
    {
      cout << "Stop: too few parameters passed to mcgen" << endl;
      cout << "Usage: mcgen.x std_devs LHAPDF_set error_type" << endl;
      exit(1);
    }

    inpdfname = argv[2];
    err_type = argv[3];
    MCStdDevs();
  }
  else if (strcmp(argv[1], "average") == 0)
  { // Compute the zeroth replica,
    // equal to the MC average of all non-zero replicas in the MC ensemble
    if (argc < 5)
    {
      cout << "Stop: too few parameters passed to mcgen" << endl;
      cout << "Usage: mcgen.x average average.dat input1.dat input2.dat ..." << endl;
      exit(1);
    }

    MCaverage(argc, argv);
  }
  else if ((strcmp(argv[1], "add") == 0) ||
           (strcmp(argv[1], "multiply") == 0))
  { // Add or multiply two LHAPDF grids
    if (argc < 5)
    {
      cout << "Stop: too few parameters passed to mcgen" << endl;
      cout << "Usage: mcgen.x add sum.dat input1.dat input2.dat w1 w2" << endl;
      cout << "Usage: mcgen.x multiply prod.dat input1.dat input2.dat power1 power2" << endl;
      exit(1);
    }

    MCadd(argc, argv);
  }
  else
  {
    cout << "mcgen does not recognize requested operation " << argv[1] << endl;
    exit(1);
  }

  return 0;
} // main -> ==============================================================

int MCread_card()
// Read parameters of the calculation from an input card
//========================================================================
{
  string dummy;

  cout << "Reading parameters from the input card" << endl;
  ifstream infile(cardname.c_str());

  if (infile.fail())
  {
    cout << "Problem with reading " << cardname << endl;
    exit(1);
  }

  getline(infile, dummy);
  getline(infile, dummy);
  getline(infile, inpdfname, '#');
  getline(infile, dummy);
  trim_right(inpdfname); // input PDF name
  getline(infile, outpdfname, '#');
  getline(infile, dummy);
  trim_right(outpdfname); // output PDF name
  getline(infile, err_type, '#');
  getline(infile, dummy);
  trim_right(err_type); // error type (Hessian/MC)

  infile >> nmc;
  getline(infile, dummy); // number of MC replicas to generate
  infile >> nstart;
  getline(infile, dummy); // the starting random number
  infile >> ktype;
  getline(infile, dummy);   // type of the replicas;
  nsym = ktype % 10;        // symmetric or asymmetric PDF error
  nshift = abs(ktype / 10); // shifted replicas or not
  getline(infile, xlhaname, '#');
  getline(infile, dummy); // grid of output x values
  trim_right(xlhaname);
  getline(infile, qlhaname, '#');
  getline(infile, dummy); // grid of output Q values
  trim_right(qlhaname);

  infile.clear();
  infile.close();

  return 0;
} // MCread_card -> ========================================================

int MCGenerateLHAPDF()
// Generate LHAPDF files for MC replicas
//========================================================================
{

  //lk23 added another dimension to xgrid and qgrid to accomodate subgrids.
  vector<vector<double>> xgrid, qgrid; // Vectors with x and Q values
  double num, ErrorScaling, pdiff;

  int nxtot = 0, nqtot = 0, iran, nmcmax;

  ifstream infile;   // input file stream
  ofstream outfile;  // output file stream
  vector<double> rn; // array with random displacements

  // lk23 added another dimension to pdfin, pdfout, mean, and var to accomodate subgrids.
  vector<vector<vector<vector<vector<double>>>>> pdfin, pdfout;
  vector<vector<vector<vector<double>>>> mean, var;

  // Prepare random displacements for conversion of Hessian replicas
  if (strcmp(err_type.c_str(), "he90") == 0)
    ErrorScaling = 1 / 1.65;
  else
    ErrorScaling = 1.0;

  // Open the LHAPDF6 object for the input PDFs
  LHAPDF::PDFSet set(inpdfname);
  const int nmem = set.size() - 1; // number of PDF sets in the input PDF ensemble,
                                   // including the zeroth set
  vector<LHAPDF::PDF *> pdfs = set.mkPDFs();

  // For Monte-Carlo input replicas, check that the number of required replicas
  // does not exceed the number of input replicas
  if (strcmp(err_type.c_str(), "mc") == 0)
  {
    nmcmax = nstart + nmc - 1; // maximal number of the input replicas
    if (nmcmax > nmem)
    {
      cout << "GenerateMCLHAPDF: The number of final replicas exceeds "
           << "the number of input member sets in the LHAPDF grid" << endl;
      cout << "Number of input member sets = " << nmem;
      cout << "Number of final replicas, # of replicas to skip = "
           << nmc << ", " << nstart << endl;
      exit(1);
    } // if (nmcmax > nmem..
  }   // if err_type == "mc"

  // For Hessian input replicas, read in enough random numbers from an external file
  // randnum_gaussian.dat. The file contains random numbers from a standard
  // normal distribution defined on the interval (-infty, infty).
  string fname = "../inc/randnum_gaussian.dat";
  if (err_type != "mc")
  {
    // number of random seeds that have been read, to skip at the beginning,
    // and to read in total
    iran = 0;
    int nskip = (nstart - 1) * nmem;
    nmcmax = nmc * nmem;
    int nstop = nskip + nmcmax;

    infile.open(fname.c_str());

    while (infile.good() &&
           (iran < nstop))
    {
      infile >> num;
      if (iran > nskip)
        rn.push_back(num);
      iran++;
    }
    infile.clear();
    infile.close();

    if (iran < nstop)
    {
      cout << "GenerateMCPLT: Not enough input random displacements" << endl;
      cout << "Reduce the number of final replicas or starting number" << endl;
      exit(1);
    }
  } // if err_type != "mc"

  // lk23 pull flavors from grid
  const std::vector<int> LHAPDFflavors = pdfs[0]->flavors();
  // PDF flavors to write to the LHAPDF grid
  const int nfltot = LHAPDFflavors.size(); // Maximal number of PDF flavors

  // lk23 Get the the x and q2 values from the 0th grid
  int member_index = 0; // 0 corresponds to the central PDF
  const LHAPDF::GridPDF* grid_pdf = dynamic_cast<const LHAPDF::GridPDF*>(set.mkPDF(member_index));
  // const vector<double> x_vals = grid_pdf->xKnots();
  string gridpath = LHAPDF::findpdfmempath(inpdfname, 0); // returns full path to 0th set of given PDF
  LHAGrid *grid = new LHAGrid(gridpath); // creates LHAGrid of 0th set to extract Ngrids, x, q values from
  const int nsub = grid->getNgrids();
  const vector<vector<double>> x_vals = grid->getxValuesList();
  const vector<vector<double>> q_vals = grid->getqValuesList();

  // copy values from x_vals and q_vals to xgrid and qgrid
  for (int isub=0; isub<nsub; ++isub)
    xgrid.push_back(x_vals[isub]);

  for (int isub=0; isub<nsub; ++isub)
    qgrid.push_back(q_vals[isub]);

  //lk23 write the x, q, and flavors to the output file
   outfile.open("flavor_output.txt");
   for (int i=0; i<nfltot; ++i)
     outfile << LHAPDFflavors[i] << " ";
   outfile << endl;
   outfile.clear();
   outfile.close();

  outfile.open("x_output.txt");
  for (int isub=0; isub<nsub; ++isub)
  {
    for (int j=0; j<xgrid[isub].size(); ++j)
      outfile << xgrid[isub][j] << " ";
    outfile << endl;
    outfile << "---" << endl;
  }
  outfile.clear();
  outfile.close();

  outfile.open("q_output.txt");
  for (int isub=0; isub<nsub; ++isub)
  {
    for (int j=0; j<qgrid[isub].size(); ++j)
      outfile << qgrid[isub][j] << " ";
    outfile << endl;
    outfile << "---" << endl;
  }
  outfile.clear();
  outfile.close();

  // Prepare an array pdfin to store input PDFs (nqtot x nxtot x nfltot)
  pdfin.resize(nsub);
  pdfout.resize(nsub);
  mean.resize(nsub);
  var.resize(nsub);

  //lk23 added routine to perform task for each subgrid.
  for (int isub = 0; isub < nsub; ++isub)
  {
    int nqtot = q_vals[isub].size();
    int nxtot = x_vals[isub].size();

    pdfin[isub].resize(nqtot);
    pdfout[isub].resize(nqtot);
    mean[isub].resize(nqtot);
    var[isub].resize(nqtot);
    for (int iq = 0; iq < nqtot; ++iq)
    {
      pdfin[isub][iq].resize(nxtot);
      pdfout[isub][iq].resize(nxtot);
      mean[isub][iq].resize(nxtot);
      var[isub][iq].resize(nxtot);
      for (int ix = 0; ix < nxtot; ++ix)
      {
        pdfin[isub][iq][ix].resize(nfltot);
        pdfout[isub][iq][ix].resize(nfltot);
        mean[isub][iq][ix].resize(nfltot);
        var[isub][iq][ix].resize(nfltot);
        for (int ifl = 0; ifl < nfltot; ++ifl)
        {
          pdfin[isub][iq][ix][ifl].resize(nmem + 1);
          pdfout[isub][iq][ix][ifl].resize(nmc + 1);
        } // for (int ifl
      } // for (int ix
    } // for (int iq
  } // for (int isub

  // Read the input PDFs into array pdfin
  int ninput = 0;

  BOOST_FOREACH (LHAPDF::PDF *p, pdfs)
  {
    // lk23 added routine to perform task for each subgrid
    for (int isub = 0; isub < nsub; ++isub)
    {
      int nqtot = q_vals[isub].size();
      int nxtot = x_vals[isub].size();
      for (int iq = 0; iq < nqtot; ++iq)
      {
        double q = qgrid[isub][iq];

        for (int ix = 0; ix < nxtot; ++ix)
        {
          double x = xgrid[isub][ix];

          for (int ifl = 0; ifl < nfltot; ++ifl)
          {

            int pid = LHAPDFflavors[ifl];
            double xf = p->xfxQ(pid, x, q);
            if (abs(nsym) == 2)
            { // pn2016 check the positivity, sample the log of the PDF
              if (xf < 0)
              {
                cout << "Error: log-normal sampling requires positive PDFs" << endl;
                cout << "pid, x, q, xf =" << pid << ", " << x << ", " << q << ", " << xf << endl;
                exit(1);
              }
              else if (fabs(xf) < small * x)
                xf = small * x;

              pdfin[isub][iq][ix][ifl][ninput] = log(xf);
            }
            else // sample the PDF itself
              pdfin[isub][iq][ix][ifl][ninput] = xf;

          } // for (int ifl
        } //  for (int ix
      } // for (int iq=0
    } // for (int isub

    // pn 2017
    // cout << "g(0.15,1.3) ="  << pdfin[0][95][nfltot-1][ninput] << endl;
    ninput++;

    delete p;
  } // foreach (LHAPDF::PDF* p, pdfs)

  // Create LHAPDF6 .dat file for each final MC replica.
  // imc denotes the ID of the output MC replica. The zeroth output replica,
  // corresponding to imc=0, is just the copied zeroth set of the input set
  iran = 0;
  outfile.open("MC_distances.txt"); // lk24 create header for distance output file
  outfile << "# iMC\td" << endl;
  for (int imc = 0; imc < nmc + 1; ++imc)
  {

    double rr[nmem / 2];
    double Dout = 0;
    if (err_type != "mc")
      //lk24 included routine to print out the D=(1/sqrt(nmem))Sum(rr[imem]^2) for each replica.
      for (int imem = 1; imem <= nmem / 2; imem++)
      {
	rr[imem] = rn[iran++] * ErrorScaling;
	Dout += pow(rr[imem],2); // lk24 sum the square of parameters rr
      }
    double Dout_norm = sqrt( 1. / (nmem / 2.) );
    Dout *= Dout_norm * Dout; // lk24 multiply Dout by (1 / sqrt(nmem/2) ) 
    
    outfile << imc << "\t" << Dout << endl;
    
    // lk23 added routine to perform task for each subgrid
    for (int isub = 0; isub < nsub; ++isub)
    {
      int nqtot = q_vals[isub].size();
      int nxtot = x_vals[isub].size();

      for (int ix = 0; ix < nxtot - 1; ++ix)
      { // ix=nxtot always gives pdf=0 below
        for (int iq = 0; iq < nqtot; ++iq)
        {

          for (int ifl = 0; ifl < nfltot; ++ifl)
          {

            if (strcmp(err_type.c_str(), "mc") == 0) // input MC replicas:
            // copy a replica with an offset and finish the cycle
            {
              pdfout[isub][iq][ix][ifl][imc] = pdfin[isub][iq][ix][ifl][imc + nstart - 1];
              continue;
            } // input MC replicas

            // Generate Hessian replicas
            if (imc == 0) // zeroth output replica = zeroth input replica
            {
              pdfout[isub][iq][ix][ifl][imc] = pdfin[isub][iq][ix][ifl][0];
              mean[isub][iq][ix][ifl] = 0.0; // Start accumulating mean
              var[isub][iq][ix][ifl] = 0.0;  // and variance
            }
            else if (imc < nmc)
            {
              double f0, fm, fp, df1, df2, pout[15];
              f0 = pdfin[isub][iq][ix][ifl][0];
              pout[ifl] = f0;

              for (int l = 1; l <= nmem / 2; l++)
              {
                fm = pdfin[isub][iq][ix][ifl][2 * l - 1];
                fp = pdfin[isub][iq][ix][ifl][2 * l];

                if (nsym == -3)
                {                // Watt-Thorne'2012 asym. error
                  if (rr[l] > 0) // choose positive error
                    pdiff = fp - f0;
                  else // choose negative error
                    pdiff = fm - f0;
                  pout[ifl] += pdiff * fabs(rr[l]);
                  continue;
                } // nsym == -3

                // Default CT sequence: an estimate of the first derivative
                df1 = (fp - fm) / 2.0;
                pout[ifl] += df1 * rr[l];

                if (nsym < 0) // asymmetric errors;
                {             // add an estimate of the second derivative
                  df2 = fp + fm - 2 * f0;
                  pout[ifl] += 0.5 * df2 * rr[l] * rr[l];
                } // asymmetric errors
                // pn 2017
                // if (ix == 95 && iq==0 && ifl == nfltot-1)
                //   cout << "imc, l, f0, fm, fp, rr, df, = "<<imc << " "<<l<<" "
                //        <<f0<<" "<<fm<<" "<<fp<<" "<<rr[l]<<" "<<
                //     df1*rr[l]+0.5*df2*rr[l]*rr[l]<<endl;

              } // for (int l=1...

              pdfout[isub][iq][ix][ifl][imc] = pout[ifl];
              mean[isub][iq][ix][ifl] += pout[ifl];            // accumulate the mean replica
              var[isub][iq][ix][ifl] += pout[ifl] * pout[ifl]; // and the variance
            }
            else // imc = nmc; apply shifts if requested;
                 // the last MC replica is the mean of all previous replicas
            {
              mean[isub][iq][ix][ifl] /= nmc;
              var[isub][iq][ix][ifl] = var[isub][iq][ix][ifl] / nmc - mean[isub][iq][ix][ifl] * mean[isub][iq][ix][ifl];
              pdfout[isub][iq][ix][ifl][imc] = mean[isub][iq][ix][ifl];

              if (nshift != 0)
                for (int jmc = 1; jmc < nmc + 1; ++jmc)
                {
                  double shift = pdfout[isub][iq][ix][ifl][0] - mean[isub][iq][ix][ifl];
                  if (abs(nsym) == 2) // additional contribution for the log shift
                    shift -= var[isub][iq][ix][ifl] / 2;

                  pdfout[isub][iq][ix][ifl][jmc] += shift;
                } // if(nshift != 0)
            }     // imc = nmc -1

          } // for (int ifl=...
        } // for (int iq
      } // for (int ix
    } // for (int isub
  } // for (int imc #1...
  outfile.clear(); // lk24 clear and close outfile after finishing imc loop
  outfile.close();

  // Create LHAPDF6 .dat file for each final MC replica.
  // imc denotes the ID of the output MC replica. The zeroth output replica,
  // corresponding to imc=-1, is just the copied zeroth set of the input set
  for (int imc = 0; imc < nmc + 1; ++imc)
  {

    // Generate the name of the .dat file
    if (imc < 10)
    {
      fname = outpdfname + "_000" + boost::lexical_cast<string>(imc) + ".dat";
    }
    else if (imc < 100)
    {
      fname = outpdfname + "_00" + boost::lexical_cast<string>(imc) + ".dat";
    }
    else if (imc < 1000)
    {
      fname = outpdfname + "_0" + boost::lexical_cast<string>(imc) + ".dat";
    }
    else
    {
      fname = outpdfname + "_" + boost::lexical_cast<string>(imc) + ".dat";
    }

    // Write the header into the .dat file
    outfile.open(fname.c_str());
    outfile << "PdfType: central" << endl;
    outfile << "Format: lhagrid1" << endl;
    outfile << "---" << endl;

    //lk23 added routine to perform task for each subgrid when writing to file.
    for (int isub = 0; isub < nsub; ++isub)
    {
      int nqtot = q_vals[isub].size();
      int nxtot = x_vals[isub].size();

      // Write the x grid into the .dat file
      for (int ix = 0; ix < nxtot; ++ix)
      {
        if (ix == 0)
          outfile << scientific << setprecision(6) << xgrid[isub][ix];
        else
          outfile << " " << scientific << setprecision(6) << xgrid[isub][ix];
      }

      outfile << endl;

      // Write the Q grid into the .dat file
      for (int iq = 0; iq < nqtot; ++iq)
      {
        if (iq == 0)
          outfile << scientific << setprecision(6) << qgrid[isub][iq];
        else
          outfile << " " << scientific << setprecision(6) << qgrid[isub][iq];
      }
      outfile << endl;

      // Write the PDF values into the .dat file
      for (int i = 0; i < nfltot; ++i)
        outfile << LHAPDFflavors[i] << " ";
      outfile << endl;

      for (int ix = 0; ix < nxtot; ++ix)
      {
        for (int iq = 0; iq < nqtot; ++iq)
        {
          for (int ifl = 0; ifl < nfltot; ++ifl)
          {

            if (ix == (nxtot - 1))
            { // last point; just write 0
              outfile << setw(16) << scientific << setprecision(8) << 0.0;
              continue;
            }

            if (abs(nsym) == 2) // log-normal sampling
              pdfout[isub][iq][ix][ifl][imc] = exp(pdfout[isub][iq][ix][ifl][imc]);

            outfile << setw(16) << scientific << setprecision(8) << pdfout[isub][iq][ix][ifl][imc];
          } // for (int ifl=...
          outfile << endl;
        } // for (int iq
      } // for (int ix

      outfile << "---" << endl;
    } // for (int isub...

    outfile.clear();
    outfile.close();

  } // for (int imc #2...

  return 0;
} // MCGenerateLHAPDF -> ===================================================

int MCLHAPDF2plt()
// Convert LHAPDF files into .plt files
//========================================================================
{

  vector<double> xgrid, xigrid, qgrid; // Vectors with x and Q values
  double num;
  int nxtot = 0, nqtot = 0;

  ifstream infile;  // input file stream
  ofstream outfile; // output file streams
  string fname;

  vector<vector<vector<vector<double>>>> pdfin; // stores input PDFs

  // Open the LHAPDF6 object for the input PDFs
  LHAPDF::PDFSet set(inpdfname);
  vector<LHAPDF::PDF *> pdfs = set.mkPDFs();
  const int nmem = set.size() - 1; // number of PDF sets in the input PDF ensemble,
  // including the zeroth set

  // lk23 pull flavors from grid
  std::vector<int> inflavors = pdfs[0]->flavors();
  // PDF flavors to write to the LHAPDF grid
  const int nfltot = inflavors.size(); // Maximal number of PDF flavors
  // lk24 created to match META representation
  std::vector<int> outflavors = inflavors;


  // lk25 sort flavors to fit temporary META representation
  // Replace 21 with 0 in the copy
  for (int i = 0; i < nfltot; ++i)
    if (outflavors[i] == 21)
      outflavors[i] = 0;

  // Sort the copy of the array
  std::sort(outflavors.begin(), outflavors.end());

  // Replace 0 back to 21 in the sorted copy
  for (int i = 0; i < nfltot; ++i)
    if (outflavors[i] == 0)
      outflavors[i] = 21;  

  for (int i = 0; i < nfltot; i++)
    cout << outflavors[i] << " " << endl;
  
  // // Order LHAPDF flavor indices in PDF flavor order (u<->d)
  // for (int i = 0; i < inflavors.size(); i++)
  // {
  //   if (inflavors[i] == -2)
  //     inflavors[i] = -1;
  //   else if (inflavors[i] == -1)
  //     inflavors[i] = -2;
  //   else if (inflavors[i] == 1)
  //     inflavors[i] = 2;
  //   else if (inflavors[i] == 2)
  //     inflavors[i] = 1;
  // }


  vector<double> xingrid, qingrid; // define x, and Q grids for the output config file
  int nxintot = 0, nqintot = 0;

  // lk24 Get the x and q2 values from the 0th LHAgrid and print out values in external file
  int member_index = 0; // 0 corresponds to the central PDF
  const LHAPDF::GridPDF* grid_pdf = dynamic_cast<const LHAPDF::GridPDF *>(set.mkPDF(member_index));
  const vector<double> xin_vals = grid_pdf->xKnots();

  nxintot = xin_vals.size();
  for (int i = 0; i < nxintot; ++i)
    xingrid.push_back(xin_vals[i]);

  const vector<double> q2in_vals = grid_pdf->q2Knots();
  nqintot = q2in_vals.size();
  for (int i = 0; i < nqintot; ++i)
    qingrid.push_back(sqrt(q2in_vals[i]));

  //lk23 added routine to add and subtract 0.005 GeV to repeating Q values
  double epsilon = 0.005;
  for (int i = 0; i < nqtot - 1; ++i)
  {
    if (qingrid[i] == qingrid[i + 1])
    {
      qingrid[i+1] += epsilon;
      qingrid[i] -= epsilon;
    }
  }

  // lk24 read x adn q values from external file xpltname qpltname
  //Read hardwired x values for .plt files
  infile.open(xpltname.c_str());

  while (infile.good()) {  
    infile >> num;
    xgrid.push_back(num);
    nxtot++;
  }
  infile.clear();
  infile.close();

  //Read hardwired Q values for the .plt grid
  infile.open(qpltname.c_str());
  while (infile >> num) {  
    qgrid.push_back(num);
    nqtot++;
  }
  infile.clear();
  infile.close();

  

  // lk24 parse mc, mb, mt, alphas_MZ, MZ, alphas_OrderQCD, NumFlavors, and OrderQCD using get_entry()   
  double mcin = stod(set.get_entry("MCharm"));
  double mbin = stod(set.get_entry("MBottom"));
  double mtin = stod(set.get_entry("MTop"));

  double alphasMZin = stod(set.get_entry("AlphaS_MZ"));
  double mzin = stod(set.get_entry("MZ"));
  int alphas_orderin = stoi(set.get_entry("AlphaS_OrderQCD"));

  int NumFlavsin = stoi(set.get_entry("NumFlavors"));
  int orderqcdin = stoi(set.get_entry("OrderQCD"));

  // lk25 added Q0, number of EV sets, and PDG hadron ID for the new .mev format
  double Q0in = stod(set.get_entry("QMin"));
  int NEVin = stoi(set.get_entry("NumMembers")) - 1; 
  //int iPDGin = stoi(set.get_entry("Particle"));
  
  // lk25 commented out config file
  /*
  // lk24 write the xin, qin, and flavors to the output file
  outfile.open(inpdfname + "_mp4lhc_gridgen.config");
  outfile << "# mc  mb  mt  alphas_mZ  mZ  alphas_order  Nfl  Order_QCD" << endl;
  outfile << mcin << "  " << mbin << "  " << mtin << "  " << alphasMZin << "  " << mzin << "  " << alphas_orderin << "  " << NumFlavsin << "  " << orderqcdin << endl;
  outfile << "# flavors: " << endl;
  for (int i = 0; i < nfltot-1; ++i)
    outfile << outflavors[i] << "  ";
  outfile << outflavors [nfltot-1] << endl;
  outfile << "# x values: " << endl;
  for (int i = 0; i < nxintot-1; ++i)
    outfile << xingrid[i] << "  ";
  outfile << xingrid[nxintot-1] << endl;
  outfile << "# q values: " << endl;
  for (int i = 0; i < nqintot-1; ++i)
    outfile << qingrid[i] << "  ";
  outfile << qingrid[nqintot-1] << endl;
  
  outfile.clear();
  outfile.close();
  */

  // lk25 create .mev file v.2025-02 from Pavel
  outfile.open(inpdfname + ".mev_header");
  outfile << "#v.2025-02# .mev file created from " + inpdfname + "LHAPDF set" << endl;
  outfile << orderqcdin << ", " << Q0in << ", " << alphasMZin << ", " << mzin << " # QCD order ,Q0 (GeV), alphas(MZ), MZ" << endl;
  outfile << mcin << ", " << mbin << ", " << mtin << " # mcharm, mbottom, mtop (GeV)" << endl;
  outfile << NEVin << ", iPDG # Number of EV sets, PDG hadron ID (2212=proton, 211=pi+)" << endl;
  outfile << "# Flavors in the LHAPDF grid and compressed META representation" << endl;
  for (int i = 0; i < nfltot-1; i++)
    outfile << outflavors[i] << ", ";
  outfile << outflavors[nfltot-1] << endl;
  outfile << "# enter META representation here" << endl; //lk25 replace line with either evolution basis IDs or physical
  outfile << "# x values:" << endl;
  for (int i = 0; i < nxtot-1; i++)
    outfile << xgrid[i] << "\t";
  outfile << xgrid[nxtot-1] << endl;
  outfile << "# q values:" << endl;
  for (int i = 0; i < nqtot-1; i++)
    outfile << qgrid[i] << "\t";
  outfile << qgrid[nqtot-1] << endl;
  // lk25 commented out to print out just the header for mp4lhc
  // for (int imem = 0; imem < NEVin + 1; imem++)
  // {
  //   outfile << "# EV set " << imem << "---" << endl;
  //   for (int ifl = 0; ifl < nfltot; ifl++)
  //   {
  //     for (int ix = 0; ix < nxtot-1; ix++)
  // 	outfile << "[" << outflavors[ifl] << "][" << ix << "]\t";
  //     outfile << "[" << outflavors[ifl] << "][" << nxtot-1 << "]" << endl;
  //   }
  // }
  outfile.clear();
  outfile.close();
  
  
  // lk23 write the x, q, and flavors to the output file
  outfile.open("flavor_output.txt");
  for (int i = 0; i < nfltot; ++i)
    outfile << inflavors[i] << endl;
  outfile.clear();
  outfile.close();

  outfile.open("x_output.txt");
  for (int i = 0; i < nxtot; ++i)
    outfile << xgrid[i] << endl;
  outfile.clear();
  outfile.close();

  outfile.open("q_output.txt");
  for (int i = 0; i < nqtot; ++i)
    outfile << qgrid[i] << endl;
  outfile.clear();
  outfile.close();

  /*
  for (int i = 0; i < nqtot - 1; ++i)
  {
    if (qgrid[i] == qgrid[i + 1])
    {
      qgrid[i+1] += epsilon;
      qgrid[i] -= epsilon;
    }
  }
  */
  
  // Prepare an array pdfin to store input PDFs (nqtot x nxtot x nfltot)
  pdfin.resize(nqtot);

  for (int iq = 0; iq < nqtot; ++iq)
  {
    pdfin[iq].resize(nxtot);

    for (int ix = 0; ix < nxtot; ++ix)
    {
      pdfin[iq][ix].resize(nfltot);

      for (int ifl = 0; ifl < nfltot; ++ifl)
      {
        pdfin[iq][ix][ifl].resize(nmem + 1);
      } // for (int ifl
    } // for (int ix
  } // for (int iq

  // Read the input PDFs into array pdfin
  int ninput = 0;
  BOOST_FOREACH (LHAPDF::PDF *p, pdfs)
  {
    for (int iq = 0; iq < nqtot; ++iq)
    {
      double q = qgrid[iq];
      for (int ix = 0; ix < nxtot; ++ix)
      {
        double x = xgrid[ix];

        for (int ifl = 0; ifl < nfltot; ++ifl)
        {

          int pid = outflavors[ifl];
          const double xf = p->xfxQ(pid, x, q);
          pdfin[iq][ix][ifl][ninput] = 3. * pow(x, 2. / 3.) * xf;

        } // for (int ifl
      } //  for (int ix
    } // for (int iq=0

    ninput++;

    delete p;
  } // foreach (LHAPDF::PDF* p, pdfs)

  // Create .plt file for each input replica.
  // imc denotes the ID of the output MC replica.
  for (int imc = 0; imc < nmem + 1; ++imc)
  {

    // Generate the name of the .plt file
    if (imc < 10)
      fname = inpdfname + "_000" + boost::lexical_cast<string>(imc) + ".plt";
    else if (imc < 100)
      fname = inpdfname + "_00" + boost::lexical_cast<string>(imc) + ".plt";
    else if (imc < 1000)
      fname = inpdfname + "_0" + boost::lexical_cast<string>(imc) + ".plt";
    else
      fname = inpdfname + "_" + boost::lexical_cast<string>(imc) + ".plt";

    // Write the header into the .dat file
    outfile.open(fname.c_str());

    for (int iq = 0; iq < nqtot; ++iq)
    {
      double qq = qgrid[iq];
      outfile << "#   Q = " << setw(15) << scientific << setprecision(6) << qq << endl;
      outfile << "# ZZ\tx\tbbar\tcbar\tsbar\tubar\tdbar\tg\td\tu\ts\tc\tb" << endl;

      for (int ix = 0; ix < nxtot; ++ix)
      {

        double pout[nfltot + 2] = {};
        pout[0] = 1.;
        pout[1] = xgrid[ix];

        for (int ifl = 0; ifl < nfltot; ++ifl)
          pout[2 + ifl] = pdfin[iq][ix][ifl][imc];

        for (int ifl = 0; ifl < nfltot + 2; ++ifl)
          outfile << setw(15) << scientific << setprecision(6) << pout[ifl];
        outfile << endl;

      } // for (int ix
    } // for (int iq

    outfile.clear();
    outfile.close();

  } // for (int imc...

  return 0;

} // MCLHAPDF2plt -> ==============================================================

int MCStdDevs()
// Compute central PDF values, standard deviations, and other miscellaneous
// information for the provided LHAPDF ensemble inpdfname. Write this information
// into inpdfname_ce.er, inpdfname_up.err, inpdfname_dn.err files.
//========================================================================
{

  vector<double> xgrid, xigrid, qgrid; // Vectors with x and Q values
  double num, ErrorScaling, auxu, auxd;
  int nxtot = 0, nixtot = 0, nqtot = 0, ierr;

  ifstream infile;                 // input file stream
  ofstream outfile, outerrfile[3]; // output file streams

  const char *strarray[] = {"ce.err", "up.err", "dn.err"};
  vector<string> outerrname(strarray, strarray + 3);

  vector<vector<vector<vector<double>>>> pdfin;      // stores input PDFs
  vector<vector<vector<double>>> pdferr[3];          // store PDF errors
  vector<vector<vector<double>>> &pdfce = pdferr[0], // aliases for arrays
      &pdfu1 = pdferr[1], &pdfd1 = pdferr[2];        // with PDF errors

  // Prepare random displacements for conversion of Hessian replicas
  if (strcmp(err_type.c_str(), "he90") == 0)
    ErrorScaling = 1 / 1.65;
  else
    ErrorScaling = 1.0;

  // Open the LHAPDF6 object for the input PDFs
  LHAPDF::PDFSet set(inpdfname);
  const int nmem = set.size() - 1; // number of PDF sets in the input PDF ensemble,
  // including the zeroth set
  vector<LHAPDF::PDF *> pdfs = set.mkPDFs();

  // lk23 pull flavors from grid and create outflavors
  std::vector<int> inflavors = pdfs[0]->flavors();
  const int nfltot = inflavors.size(); // Maximal number of PDF flavors in
  // Create a copy of the original array
  std::vector<int> outflavors(nfltot);
  //std::copy(inflavors.begin(), inflavors.end(), outflavors.begin());

  //lk23 sort inflavors in plt format
  //std::sort(inflavors.begin(), inflavors.end(), pltSort);

  // Replace 21 with 0 in the copy
  for (int i = 0; i < nfltot; ++i)
    if (outflavors[i] == 21)
      outflavors[i] = 0;

  // Sort the copy of the array
  std::sort(outflavors.begin(), outflavors.end());

  // Replace 0 back to 21 in the sorted copy
  for (int i = 0; i < nfltot; ++i)
    if (outflavors[i] == 0)
      outflavors[i] = 21;

   /*
  // lk23 Get the the x and q2 values from the 0th grid
  int member_index = 0; // 0 corresponds to the central PDF
  const LHAPDF::GridPDF *grid_pdf = dynamic_cast<const LHAPDF::GridPDF *>(set.mkPDF(member_index));
  const vector<double> x_vals = grid_pdf->xKnots();
  nxtot = x_vals.size();
  for (int i = 0; i < nxtot; ++i)
    xgrid.push_back(x_vals[i]);

  const vector<double> q2_vals = grid_pdf->q2Knots();
  nqtot = q2_vals.size();
  for (int i = 0; i < nqtot; ++i)
    qgrid.push_back(sqrt(q2_vals[i]));

  //lk23 added routine to add and subtract 0.005 GeV to repeating Q values
  double epsilon = 0.005;
  for (int i = 0; i < nqtot - 1; ++i)
  {
    if (qgrid[i] == qgrid[i + 1])
    {
      qgrid[i+1] += epsilon;
      qgrid[i] -= epsilon;
    }
  }
  */

  //lk24 changed x and q values to be read from external file and not grid
  //Read hardwired x values for .plt files
  infile.open(xpltname.c_str());

  while (infile.good()) {  
    infile >> num;
    xgrid.push_back(num);
    nxtot++;
  }
  infile.clear();
  infile.close();

  //Read hardwired Q values for the .plt grid
  infile.open(qpltname.c_str());
  while (infile >> num) {  
    qgrid.push_back(num);
    nqtot++;
  }
  infile.clear();
  infile.close();

  // lk23 write the x, q, and flavors to the output file
  outfile.open("flavor_output.txt");
  for (int i = 0; i < nfltot; ++i)
    outfile << inflavors[i] << endl;
  outfile.clear();
  outfile.close();

  outfile.open("x_output.txt");
  for (int i = 0; i < nxtot; ++i)
    outfile << xgrid[i] << endl;
  outfile.clear();
  outfile.close();

  outfile.open("q_output.txt");
  for (int i = 0; i < nqtot; ++i)
    outfile << qgrid[i] << endl;
  outfile.clear();
  outfile.close();

  // Read hardwired x values for .int file
  string fname = "../inc/evo-xg.gd";
  infile.open(fname.c_str());

  while (infile.good())
  {
    infile >> num;
    xigrid.push_back(num);
    nixtot++;
  }
  infile.clear();
  infile.close();

  // Prepare an array pdfin to store input PDFs (nqtot x nxtot x nfltot)
  pdfin.resize(nqtot);
  for (ierr = 0; ierr <= 2; ierr++)
    pdferr[ierr].resize(nqtot);

  for (int iq = 0; iq < nqtot; ++iq)
  {
    pdfin[iq].resize(nxtot);
    for (ierr = 0; ierr <= 2; ierr++)
      pdferr[ierr][iq].resize(nxtot);

    for (int ix = 0; ix < nxtot; ++ix)
    {
      pdfin[iq][ix].resize(nfltot);
      for (ierr = 0; ierr <= 2; ierr++)
        pdferr[ierr][iq][ix].resize(nfltot);

      for (int ifl = 0; ifl < nfltot; ++ifl)
      {
        pdfin[iq][ix][ifl].resize(nmem + 1);
      } // for (int ifl
    } // for (int ix
  } // for (int iq

  // Read the input PDFs into array pdfin
  int ninput = 0;
  BOOST_FOREACH (LHAPDF::PDF *p, pdfs)
  {
    for (int iq = 0; iq < nqtot; ++iq)
    {
      double q = qgrid[iq];
      for (int ix = 0; ix < nxtot; ++ix)
      {
        double x = xgrid[ix];

        for (int ifl = 0; ifl < nfltot; ++ifl)
        {

          int pid = outflavors[ifl];
          const double xf = p->xfxQ(pid, x, q);
          pdfin[iq][ix][ifl][ninput] = 3. * pow(x, 2. / 3.) * xf;

        } // for (int ifl
      } //  for (int ix
    } // for (int iq=0

    if (ninput == 0)
    { // Write the central PDF into a .int file
      fname = inpdfname + ".int";
      outfile.open(fname.c_str());
      for (int ifl = 0; ifl < nfltot; ++ifl)
      {
        int pid = outflavors[ifl];
        for (int ix = 0; ix < nixtot; ++ix)
        {
          double x = xigrid[ix];
          const double ff = (p->xfxQ(pid, x, 8.)) / x;
          outfile << setw(15) << scientific << setprecision(6) << ff;
        }
        outfile << endl;
      }
      outfile.clear();
      outfile.close();
    } // if (ninput == 0)

    ninput++;

    delete p;
  } // foreach (LHAPDF::PDF* p, pdfs)

  // Write input 68% c.l. errors into .er files
  for (int iq = 0; iq < nqtot; ++iq)
  {
    for (int ix = 0; ix < nxtot; ++ix)
    {
      for (int ifl = 0; ifl < nfltot; ++ifl)
      {

        // central PDF value
        pdfce[iq][ix][ifl] = pdfin[iq][ix][ifl][0];

        double sumup = 0.0, sumdn = 0.0;

        for (int n = 1; n <= nmem / 2; ++n)
        {
          if (strcmp(err_type.c_str(), "mc") == 0)
          { // MC symmetric errors
            auxu = (pdfin[iq][ix][ifl][2 * n] - pdfin[iq][ix][ifl][0]) * (pdfin[iq][ix][ifl][2 * n] - pdfin[iq][ix][ifl][0]) + (pdfin[iq][ix][ifl][2 * n - 1] - pdfin[iq][ix][ifl][0]) * (pdfin[iq][ix][ifl][2 * n - 1] - pdfin[iq][ix][ifl][0]);
            auxd = auxu;
          }
          else
          { // Hessian asymmetric errors
            auxu = max(max(pdfin[iq][ix][ifl][2 * n] - pdfin[iq][ix][ifl][0],
                           pdfin[iq][ix][ifl][2 * n - 1] - pdfin[iq][ix][ifl][0]),
                       0.);
            auxd = max(max(pdfin[iq][ix][ifl][0] - pdfin[iq][ix][ifl][2 * n],
                           pdfin[iq][ix][ifl][0] - pdfin[iq][ix][ifl][2 * n - 1]),
                       0.);
            auxu *= auxu;
            auxd *= auxd;
          }

          sumup += auxu;
          sumdn += auxd;

        } // for (int n=1; n<=nmem/2

        if (strcmp(err_type.c_str(), "mc") == 0)
        { // MC symmetric errors
          pdfu1[iq][ix][ifl] = sqrt(sumup / max(nmem - 2, 1));
          pdfd1[iq][ix][ifl] = sqrt(sumdn / max(nmem - 2, 1));
        }
        else
        { // Hessian errors
          pdfu1[iq][ix][ifl] = sqrt(sumup);
          pdfd1[iq][ix][ifl] = sqrt(sumdn);
          if (strcmp(err_type.c_str(), "he90") == 0)
          {
            pdfu1[iq][ix][ifl] *= ErrorScaling;
            pdfd1[iq][ix][ifl] *= ErrorScaling;
          }
        } // if (err_type == "mc"...

      } // for (int ifl=0; ifl
    } // for (int ix=0; ix<nxtot; ++ix)
  } // for (int iq=0; iq<nqtot; ++iq)

  // write all errors into .err files
  for (int ierr = 0; ierr <= 2; ierr++)
  {
    outerrname[ierr] = inpdfname + "_" + outerrname[ierr];
    outerrfile[ierr].open(outerrname[ierr].c_str());

    for (int iq = 0; iq < nqtot; ++iq)
    {
      double qq = qgrid[iq];
      outerrfile[ierr] << "#   Q = " << qq << endl;
      outerrfile[ierr] << "# ZZ" << endl;
      for (int ix = 0; ix < nxtot; ++ix)
      {
        double xx = xgrid[ix];
	// lk24 commented out Z and x values from pdf err files
        outerrfile[ierr] << setw(15) << scientific << setprecision(6) << 1.0;
        outerrfile[ierr] << setw(15) << scientific << setprecision(6) << xx;
        for (int ifl = 0; ifl < nfltot; ++ifl)
          outerrfile[ierr] << setw(15) << scientific
                           << setprecision(6) << pdferr[ierr][iq][ix][ifl];

        outerrfile[ierr] << endl;
      } // for int ix
    } // for (int iq

    outerrfile[ierr].clear();
    outerrfile[ierr].close();
  } // for int ierr

  return 0;

} // MCStdDevs -> ==============================================================

int MCaverage(int argc, char *argv[])
//========================================================================
// Usage: MCaverage average outgrid ingrid1 ingrid2 ...
// Creates an LHAPDF grid outgrid containing the average of PDFs in
// LHAPDF grids ingrid1 ingrid2....
{
  if ((string)argv[1] != "average")
  {
    cout << "Usage MCaverage:" << endl;
    cout << "MCaverage average out_lha_grid.dat in_lha_grid1.dat in_lha_grid2.dat ..." << endl;
    exit(1);
  }

  string outpdfname = argv[2];
  unsigned short int operation;
  if (strcmp(argv[1], "add") == 0)
    operation = 1;
  else
    operation = 2;

  // lk23 use custom object to calculate average
  const int Nindat = argc - 3; // number of input files

  vector<string> inputpdfnames;
  for (int ifile = 0; ifile < Nindat; ifile++)
  // create vector of grids to be averaged by reading
  {
    string inputpdfname = argv[ifile + 3];
    inputpdfnames.push_back(inputpdfname);
  }

  LHAGrid outputgrid(argv[1], inputpdfnames);
  outputgrid.WriteLHAGrid(outpdfname);

  return 0;
} // MCaverage ->

int MCadd(int argc, char *argv[])
//========================================================================
// Usage: MCadd add outgrid ingrid1 ingrid2 w1 w2
// Creates an LHAPDF grid outgrid containing the sum of PDFs in
// LHAPDF grids ingrid1 and ingrid2, multiplied by real numbers
// w1 and w2. The PDFs in the final grid satistfy
//
// pdf(x, Q, ifl, out) = w1*pdf(x,Q,ifl,in1) + w2*pdf(x,Q,ifl,in2).
{
  string outpdfname = argv[2];
  /* unsigned short int operation;
  if (strcmp(argv[1],"add")==0)
    operation = 1;
  else
    operation = 2;  */

  const int Nindat = 2; // number of input files

  // lk23 create vector of weights to pass
  vector<double> w;
  double w1 = boost::lexical_cast<double>(argv[5]);
  double w2 = boost::lexical_cast<double>(argv[6]);
  w.push_back(w1);
  w.push_back(w2);

  // lk23 create a vector of input pdf names to create output grid
  string inputpdfname1 = argv[3];
  string inputpdfname2 = argv[4];
  vector<string> inputpdfnames;
  inputpdfnames.push_back(inputpdfname1);
  inputpdfnames.push_back(inputpdfname2);

  // lk23 use custom object to calculate sum or multiplication of input grids
  LHAGrid outputgrid(argv[1], inputpdfnames, w);
  outputgrid.WriteLHAGrid(outpdfname);

  return 0;
} // MCadd ->

// lk23 added function to sort flavors plt format
bool pltSort(int a, int b) 
{
  int abs_a = std::abs(a);
  int abs_b = std::abs(b);

  // Check if a or b is 21
  if (abs_a == 21 || abs_b == 21) 
    // If either is 21, it should come first
    return abs_a == 21;

  // Check if a is -2 and b is 2, in which case -2 should come before 2
  if (abs_a == 2 && abs_b == 2)
    return a > b;

  // Check if a or b is 2 or -2
  if (abs_a == 2 || abs_b == 2)
    // If either is 2 or -2, it should come before 1 or -1
    return abs_a == 2;

  // Check if both numbers have the same absolute value
  if (abs_a == abs_b) 
    // If absolute values are the same, sort by their sign
    return a > b;

  // If absolute values are different, sort by their absolute value
  return abs_a < abs_b;
} // pltSort ->


